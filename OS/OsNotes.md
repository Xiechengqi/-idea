# 操作系统学习笔记

## 计算机架构图

<div align=center>
<img src="./images/计算机架构.jpg"><br>计算机架构图
</div>


## 现代操作系统模块化图

<div align=center>
<img src="./images/OS1.png" width="25%" height="25%"/>
<br>现代操作系统模块化图
</div>

## 操作系统内核

* 内核，是一个操作系统的核心。是基于硬件的第一层软件扩充，提供操作系统的最基本的功能，是操作系统工作的基础，它负责管理系统的进程、内存、设备驱动程序、文件和网络系统，决定着系统的性能和稳定性
* 内核并不是计算机系统中必要的组成部分
* 操作系统内核按照体系结构分为两类 : 微内核　(microkernel)　与宏内核　(macrokernel)

### 微内核

* 只是将OS中最核心的功能加入内核，包括IPC通信、地址空间分配和基本的调度，这些东西处在内核态运行,自身仅仅是一个消息中转战,用于各种功能间的通讯
* 其他功能如设备驱动、文件系统、存储管理、网络等作为一个个处于用户态的进程而向外提供某种服务来实现，而且这些处于用户态的进程可以针对某些特定的应用和环境需求进行定制。有时，也称这些进程为服务器。
* 功能被划分成独立的进程，进程间通过 IPC 进行通信，且模块化程度高，一个服务失效不会影响另外一个服务
* 微内核的系统有 WindowNT, Minix, Mach, etc.

> IPC - InterProcess Communication - 进程间通信

### 宏内核（或单内核）

* 将OS的全部功能都做进内核中，包括调度、文件系统、网络、设备驱动器、存储管理,比如设备驱动管理、资源分配、进程间通信、进程间切换管理、文件系统、存储管理、网络等,这一切都运行在内核态，内核模块间的通讯是通过直接调用其他模块中的函数实现的（只针对于内核态的进程，内核态进程与用户态进程通信需要消息传递），无需消息传递
* 在一大块代码中实际包含了所有操作系统功能，并作为一个单一进程运行，具有唯一地址空间
* 宏内核的系统有 Unix, Linux, etc.
* Linux 是一个宏内核结构，同时又吸收了微内核的优点：模块化设计，支持动态装载内核模块，避免一次性装入所有内核造成内存浪费。但也正因为 Linux 采用宏内核，造成 Linux 系统移植到其他架构平台较难实现（传统 Linux 系统是 X86 架构的）

> 微内核是一个信息中转站，自身完成很少功能，主要是传递一个模块对另一个模块的功能请求，而宏内核则是一个大主管，把内存管理，文件管理等等一股脑全部接管。
从理论上来看，微内核的思想更好些，微内核把系统分为各个小的功能块，降低了设计难度，系统的维护与修改也容易，但通信带来的效率损失是个问题。宏内核的功能块之间的耦合度太高，造成修改与维护的代价太高，不过在目前的Linux里面还不算大问题，因为Linux目前还不算太复杂，宏内核因为是直接调用，所以效率是比较高的。

一条机器指令对应一个微程序，这个微程序是由若干条微指令构成的。因此，一条机器指令的功能是若干条微指令组成的序列来实现的。简而言之，一条机器指令所完成的操作划分成若干条微指令来完成，由微指令进行解释和执行。
 
 从一般指令的微程序执行流程图可以看出。每个CPU周期就对于一条微指令。这就告诉我们怎么设计微程序，也将使得我们进一步体验到机器指令很微指令的关系。
 
微内核是这样一种内核：它只完成内核不得不完成的功能：包括时钟中断、进程创建与销毁、进程调度，进程间通信，而其他的诸如文件系统、内存管理、设备驱动等的内容都被作为系统进程放到了用户态空间。说白了微内核是相对于宏内核而言的，像Linux就是典型的宏内核，它除了时钟中断、进程创建与销毁、进程调度、进程间通信外，其他的文件系统、内存管理、输入输出、设备驱动管理都需要内核完成；像windows，虽然ms标榜说其是微内核的，但是据说它连GUI都放到了内核空间。其实内核就是一个运行在ring0（最高）级别的程序片段，它能完成ring3（用户态）不能完成的一些功能。微内核通过进程间通信来协调各个系统进程间的合作，这就需要系统调用，而系统调用需要切换堆栈以及保护进程现场，比较耗费时间；而宏内核都是通过简单的函数调用来完成各个部门之间的合作的，所以理论上宏内核效率要比微内核高，不过沉淀到现在来说，微内核和宏内核的争论已经停止了，而且微内核也胜利了，并没有真正的实验数据说明微内核比宏内核慢。移动设备操作系统我不太懂，但是iOS应该不是Unix内核吧？应该只是类Unix系统，Linux本身也是类Unix系统。
