Linux Shell 学习时的小知识

## 目录

* [exit 0 和 exit 1](#exit-0和exit-1-top)
* [特殊变量](#特殊变量-top)
* [让一个变量获得命令输出的结果](#让一个变量获得命令输出的结果-top)
* [`命令 > /dev/null 2 > &1`和`命令 &> /dev/null`](#命令--devnull-2--1和命令--devnull-top)
* [数值比较](#数值比较-top)
* [几种数值计算方法](#几种数值计算方法-top)
* [数值进制间相互转换](#数值进制间相互转换-top)
* [等号两边不能有空格](#等号两边不能有空格-top)
* [ $( )、\` \`、${ }、$(( ))、$[ ] 、[ ]、(( )) 和 [[ ]] 详解](#---------和---详解-top)
* [用 cat 命令向文件写入](#用-cat-命令向文件写入-top)
* [杀死一个进程](#杀死一个进程-top)

## `exit 0`和`exit 1` [[Top]](#目录)

* Linux exit 命令用于退出目前的 shell
* 执行 exit 可使 shell 以指定的状态值退出
* 若不设置状态值参数，则 shell 以预设值退出；状态值 0 代表执行成功，其他值代表执行失败
* exit 也可用在 script，离开正在执行的 script，回到 shell
> 语法：exit [ 状态值 ]

<div align=center>
  <img src="./images/shell_exit.jpg"><br/>Ubuntu shell exit
 </div>

## 特殊变量 [[Top]](#目录)

| $X | 说明 |
| --- | --- |
| $? | 最近一次运行命令的结束代码（返回值 0 表示成功，非 0 表示失败） |
| $$ | 脚本运行的当前进程 ID 号（PID） |
| $n(n=1,2...) | 传递给该shell脚本的第 n 个参数 |
| $0 | 执行脚本本身的名字 |
| $# | 传递给脚本参数的个数 |
| $* | 脚本的所有参数列表,代表"$1 $2 … $n"，即当成一个整体输出，每一个变量参数之间以空格隔开 |
| $@ | 脚本的所有参数列表,代表"$1" "$2" … "$n" ，即每一个变量参数是独立的 ,也是全部输出 |

### `$*` 和 `$@`区别
``` shell 
#!/bin/bash
# This script is to verify the difference between $* and $@
 
echo Dollar Star is $*
echo "Dollar Star in double quotes is $*"
 
echo Dollar At is $@
echo "Dollar At in double quotes is $@"
 
echo 
echo "Looping through Dollar Star"
for i in $*
do
	echo "parameter is $i"
done
echo 
echo "Looping through Dollar Star with double quotes"
for i in "$*"
do
	echo "Parameter is $i"
done 
 
echo
echo "Looping through Dollar At"
for i in $@
do
	echo "Parameter is $i"
done
echo
echo "Looping through Dollar At with double quotes"
for i in "$@"
do
	echo "Parameter is $i"
done

$ bash test.sh 1 2 " 3 4 " 5 6
Dollar Star is 1 2 3 4 5 6
Dollar Star in double quotes is 1 2  3 4  5 6
Dollar At is 1 2 3 4 5 6
Dollar At in double quotes is 1 2  3 4  5 6

Looping through Dollar Star
parameter is 1
parameter is 2
parameter is 3
parameter is 4
parameter is 5
parameter is 6

Looping through Dollar Star with double quotes
Parameter is 1 2  3 4  5 6

Looping through Dollar At
Parameter is 1
Parameter is 2
Parameter is 3
Parameter is 4
Parameter is 5
Parameter is 6

Looping through Dollar At with double quotes
Parameter is 1
Parameter is 2
Parameter is  3 4 
Parameter is 5
Parameter is 6
```

> * 相同点如下：
> 1、直接输出不保留空格
> 2、带双引号输出会保留带引号的空格
> 3、不带双引号循环遍历的输出结果一样：每个字符串单独输出
> * 不同点如下：
> 1、带双引号遍历`$*`相当于带双引号输出`$*`
> 2、带双引号遍历`$@`分别输出每个参数，带双引号的参数保留空格输出

<br/>
<div align=center>
  <img src="./images/shell_$.jpg"><br/>$* 示例
 </div>

## 让一个变量获得命令输出的结果 [[Top]](#目录)

### 1、`$(命令)`表示

``` shell
#!/bin/bash
i=$(ls 123.txt)
echo $i
```

### 2、反引号表示

``` shell
#!/bin/bash
i=`ls 123.txt`
echo $i
```

## `命令 > /dev/null 2 > &1`和`命令 &> /dev/null` [[Top]](#目录)

> 解释：无提示（包括 stdin 和 stderr ）执行

<br/>
<div align=center>
  <img src="./images/shell_wj.jpg"><br/>
 </div>

 ### 文件描述符

 * 文件描述符是与文件输入、输出关联的整数。它们用来跟踪已打开的文件
 * 最常见的文件描述符是 stidin、stdout、和 stderr
  * 0 —— stdin（标准输入）
  * 1 —— stdout （标准输出）
  * 2 —— stderr （标准错误）
  
 * 我们可以将某个文件描述符的内容重定向到另外一个文件描述符中

<br/>
<div align=center>
  <img src="./images/shell_stdout.jpg"><br/>stdout （标准输出）
 </div>

 <br/>
<div align=center>
  <img src="./images/shell_stderr.jpg"><br/>stderr （标准错误）
 </div>

 ### `/dev/null`

 * `/dev/null`是一个特殊的设备文件，这个文件接收到的任何数据都会被丢弃。因此，null 这个设备通常也被成为位桶（ bit bucket ）或黑洞
 * 重定向操作给这个`/dev/null`文件的所有东西都会被丢弃

 ### 扩展使用

 ``` shell
 # 将 stderr 单独定向到一个文件，将stdout重定向到另一个文件
$ ls 123.txt 1> stdout.txt 2> stderr.txt
 # 将 stderr 转换成 stdout，使得 stderr 和 stdout 都被重新定向到同一个文件中
$ ls 123.txt 1> output.txt 2>&1
# 或
$ ls 123.txt > output.txt 2>&1
# 或
 $ ls 123.txt &> output.txt
# 或
 $ ls 123.txt >& output.txt
 ```

> * `>` 或 `1>`（标准输出）：把 STDOUT 重定向到文件,将默认或正确的传到另一个终端
> * `2>`（标准错误）：把 STDERR 重定向到文件，可将错误信息传到另一个终端，正确留下
> * `2>&1`：将错误转为正确输出，老式“洗钱”方法
> * `1>&2`：将正确转为错误输出
> * `&>`or`>&`：正确、错误都输出，新式方法

 ## 数值比较 [[Top]](#目录)

| arg1 OP arg2 ( OP ) | 说明 |
| --- | --- |
| -eq | arg1 is equal arg2 |
| -ne | arg1 is not-equal arg2 |
| -lt | arg1 is less-than arg2 |
| -le | arg1 is less-than-or-equal arg2 |
| -gt | arg1 is greater-than arg2 |
| -ge | arg1 is greater-than-or-equal arg2 |

## 几种数值计算方法 [[Top]](#目录)

 ``` shell
 $ ((i=5%2))
 $ echo $i            
 # 1
 
 $ let i=5%2
 $ echo $i            
 # 1
 
 $ expr 5 % 2
 # expr 之后的 5，%，2 之间必须有空格分开。如果进行乘法运算，需要对运算符进行转义，否则 Shell 会把乘号解释为通配符，导致语法错误
 
 $ i=$(echo 5%2 | bc)
 $ echo $i            
 # 1
  
  $ i=$(echo "5 2" | awk `{print $1+$2;}`)
  $ echo $i            
  # 1
 ```

 * `let`，`expr`，`bc` 都可以用来求模，运算符都是 `%`，而 `let` 和 `bc`可以用来求幂，运算符不一样，前者是` **`，后者是 `^ `
 * `(())` 的运算效率最高，而 `let` 作为 `Shell` 内置命令，效率也很高，但是 `expr`，`bc`，`awk` 的计算效率就比较低
* `let` 和 `expr` 都无法进行浮点运算，但是 `bc` 和 `awk` 可以
 ``` shell
 $ echo "scale=3; 1/12" | bc
 # 0.083
 
 $ echo "1 12" | awk '{printf("%0.3f\n",$1/$2)}'
 # 0.083
 ```

 ## 数值进制间相互转换 [[Top]](#目录)

 ``` shell
# 八进制 12 转换为十进制
# 方法一、
$ echo "obase=8;ibase=10;12" | bc            
# 10
# obase - 进制源
# ibase - 进制转换目标
# bc 命令是任意精度计算器语言，通常在 linux 下当计算器用
 
# 方法二、
$ echo $((8#12)                                                 
# 10
 ```

 ## 等号两边不能有空格 [[Top]](#目录)

 <div align=center>
  <img src="./images/nospace1.jpg"><br/>= 含有空格导致无法运行
 </div>

 <div align=center>
  <img src="./images/nospace2.jpg"><br/>正确
 </div>

 ## $( )、\` \`、${ }、$(( ))、$[ ] 、[ ]、(( )) 和 [[ ]] 详解 [[Top]](#目录)

|  | 说明 | 举例 | 例子说明 |
| --- | --- | --- | --- |
| $( ) | 命令替换 | `version=$(uname -r)` | 得到内核版本号 |
| \` \` | 命令替换，同 $() | version=\`uname -r\` | 同上 |
| ${ } | 用于变量替换 |  `a=1; b=${a}`  其实这里用 $a 一样，但有时会有区别 | a 赋给 b |
| $(( )) | 进行数学运算 | `echo $(( 1+2*3 ))` | 输入 1+2×3 的结果 |
| $[ ] | 进行数学运算 | `echo $[ 1+2*3 ]` | 同上 |
| [ ] | test 命令的另一种形式 | `if [ 1 eq 1 ]...` | 字面意思 |
| (( )) | 是`[  ]`的针对数学比较表达式加强版 |  |  |
| [[ ]] | 是`[  ]`的针对字符串表达式的加强版 |  |  |

 * \` \` 和 $( )：反引号几乎可以在所有 shell 上执行，而`$( )`有些不可以；多层使用反引号需要加`\`，`$( )`更浅显易懂，不易出错
 ``` shell
 $ cat a.txt
 b.txt
 $ cat b.txt
 c.txt
 $ cat c.txt
 Hello World!
 $ cat `cat \`cat a.txt\``   
 # ``内的反引号必须使用 \`
 Hello World!
 $ cat $(cat $(cat a.txt))
 Hello World!
 ```
 * bash 只能作整数运算，对于浮点数是当作字符串处理的
 * `[ ]`：必须在左括号的右侧和右括号的左侧各加一个空格，否则会报错

 ### 更多资料

http://bbs.chinaunix.net/forum.php?mod=viewthread&tid=218853&page=7#pid1617953

https://www.cnblogs.com/zejin2008/p/8412680.html

## 用 cat 命令向文件写入 [[Top]](#目录)

 <div align=center>
  <img src="./images/cat_write.jpg"><br/>
 </div>

> * 文件不存在则自动创建
> * 文件已存在，则会先删除源文件内容，在写入新内容
> * `EOF` 为开头结尾标记，可以换成任意字符串



## 杀死一个进程 [[Top]](#目录)

1. ps aux | grep 进程名 ---> kill -s 9 进程号
2. kill -s 9 \`ps aux | grep 进程名 | grep -v grep | awk '{print $2}'\`
3. ps aux | grep 进程名 | grep -v grep | xrags kill -s 9
4. kill -s 9 \`pgrep 进程名\`
5. pkill -s 9 进程名



* kill 给指定进程发送指定信号，默认发送 TERM 信号，这回杀死不能捕获该信号的进程，对于单纯 kill 杀不死的进程，可能需要使用 kill ( 9 ) 信号，因为该信号不能被任何进程捕获

*  `kill -s singal` 命令最长使用的信号：

| Signal Name | Single Value |       Effect       |
| :---------: | :----------: | :----------------: |
|   SIGHUP    |      1       |        挂起        |
|   SIGINT    |      2       |   键盘的中断信号   |
|   SIGKILL   |      9       |  发出强制杀死信号  |
|   SIGTERM   |      15      | 默认，发出终止信号 |
|   SIGSTOP   |  17, 19, 23  |      停止进程      |